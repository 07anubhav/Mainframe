COBOL (Common Business Oriented Language) – 12-15 sessions
--------
Intro COBOL Program Structure          -              Division, Section & Paragraph					-- DONE	
Variable Declarations                  -              Level Numbers, PIC clause, Data types & Size	-- DONE
Input-Output & Arithmetic              -              VALUE CLAUSE, Accept & Display - Compute		-- DONE
Data Movement Verbs                    -              Simple Move, Move with Of clause, Group Move & CORR	-- DONE
Conditional Statements                 -              IF & Evaluate Statement – Continue & Next Sentence  -- DONE
Control Sequence Verbs                 -              Perform ,STOP RUN, GOBACK, EXIT, EXIT PROGRAM, GOTO -- DONE
File Handling                          -              OPEN, READ, WRITE, REWRITE, DELETE & CLOSE	
Memory Saving                          -              Usage Clause, 88 Level Number, Redefines & Renames 66 LEVEL
Array-Occurs table                     -              Search & Search All - PERFORM VARYING
Sub-Program                            -              CALL Statement                (Static & Dynamic Call)
String Handling Verbs                  -              String, Unstring, Inspect & Referential
=============================================================================================================
1. DISPLAY PGM    2. ADDPGM01 -ABEND   3. CLAIM DATA 10 VARIABLE.    4. CUSTPGM3   5. CARDPGM1
=============================================================================================================
COBOL CLASS 09:-
===========================
File Handling                          -              OPEN, READ, WRITE, REWRITE, DELETE & CLOSE	
---
DATA IN MAINFRAME - CAN BE STORED IN   FILE  OR DATABASE
	--> HOW TO WORK WITH FILE	--> 1970 --- 1995 -DB2
===

FILE ->  COLLECTION OF RECORDS 
RECORD --> COLLECTION OF FIELDS(DATA VARIBALE)
-
FILE LAYOUT --> STURTURE OF THE FILE RECORD.

EX: ACCOUNT FILE --> OPEN - WE CAN ONLY SEE DATA RECORDS

A1111,ANIL KUMAR,98789,89222.00,SAVINGS,CLOSED,20020911			--R1  -->  ACCT-NUM, CUST-NAME
A1111,ANIL KUMAR,98789,89222.00,SAVINGS,CLOSED,20020911
A1111,ANIL KUMAR,98789,89222.00,SAVINGS,CLOSED,20020911
A1111,ANIL KUMAR,98789,89222.00,SAVINGS,CLOSED,20020911			--RN		--> R1-RN -> FILE


FILE/RECORD LAYOUT:
	
	01 ACCT-DETAILS.
		03 ACCT-NUMM		PIC  
		03 CUST-NAME
		03 BRACH-CODE
		03 ACCT-BAL
--
HOW TO CODE A FILE PGM:

			ID DIVISION.				NO CHANGES
			PROGRAM-ID. NAME-OF-PGM.
			AUTHOR. NAME.
			DATE-WRITTEN.  TODAY.

			ENVIRONMENT DIVISION.			--> REQUIRED** ON FILE PGM.
			INPUT-OUTPUT SECTION.
			FILE-CONTROL.
1ST CHANGE		SELECT  FILE-NICK-NAME-1 		ASSIGN TO  JCL-DDNAME-1
				ORGANIZATION    IS  SEQUENTIAL
				ACCESS  MODE    IS SEQUENTIAL
				FILE  STATUS    IS  WS-STATUS-VARIABLE-1.

				SELECT  FILE-NICK-NAME-2		ASSIGN TO  JCL-DDNAME-2
				ORGANIZATION    IS  SEQUENTIAL
				ACCESS  MODE    IS SEQUENTIAL
				FILE  STATUS    IS  WS-STATUS-VARIABLE-2.

			DATA DIVISION.
			FILE SECTION.														-- IN FILE SECTION VALUE CLAUSE NOT ALLOWED.
2ND CHANGE	FD  FILE-NICK-NAME-1
					LABEL RECORD ARE STANDARD.
			01 ACCOUNT-DETAILS.	
				03 ACCT-NUMBER		PIC			X(05).		
				03 CUST-NAME			PIC			X
				03 CUST-ADDRESS.
					05 CITY			PIC			X
					05 STATE			PIC			X
					05 PINCODE		PIC			X
				03 ACCT-TYPE			PIC			X
		
			FD FILE-NICK-NAME-2
				LABEL RECORD ARE STANDARD.
			01 LAYOUT-NAME		PIC			X(100).
		
			WORKING-STORAGE SECTION.
3RD CHANGE	01  WS-STATUS-VARAIBAL-1		PIC		X(02)	VALUE SPACE.
			01  WS-STATUS-VARAIBAL-2		PIC		X(02)	VALUE SPACE.

			PROCEDURE DIVISION.
4TH CHANGE
			-> ACCESS THE FILE DATA::  (ASSUME FILE AS  BOOK )

					1. OPEN THE FILE
						2. ACCESS THE  -READ / WRITE
					3. CLOSE THE FILE
				
				TEXT BOOK (INPUT FILE)		->  OPEN -- ONLY READ  -- CLOSE
				NEW NOTEBOOK (OUTPUT FILE)  ->  OPEN - ONLY WRITE  -- CLOSE
							==
							ON PS FILE DATA -> WE DONT DO UPDATE (REWRITE) 
										  -> WE CANNOT DELETE A RECORD

INPUT FILE**
				1. OPEN FILE		SYNTAX:			OPEN  INPUT	FILE-NAME.			INPUT -CALLED OPENING MODE
				2. READ:	
	
						1.	 READ FILENAME.			GET'S ONLY 1 RECORD FROM THE FILE
														-> STORE THE DATA IN THE FILE LAYOUT.

						2. ALL RECORD : KEEP THE READ IN A LOOP..

							
							READ FILENAME 
							 AT END
								-CLOSE THE LOOP
							NOT AT END
								-PROCESS THIS RECORD
							END-IF.

						3. GENERAL USED. --GET ALL RECORDS IN A LOOP

								READ FILENAME
								AT END
									-CLOSE THE LOOP.

								-PROCESS THE RECORD.

				3. CLOSE THE FILE
								CLOSE FILENAME.


OUTPUT FILE**
				1.OPEN THE FILE		SYNTAX:		OPEN OUTPUT FILENAME.

				2.    A.  PREPARE ALL OUTPUT FILE VARIBALE
					 B.  WRITE RECORD-LAYOUT-NAME.

				3. CLOSE THE FILE (AT OF PGM)		CLOSE FILENAME.


READ-->  FROM FILE		-> SYNTAX:		READ FILENAME.
WRITE -> FROM VARIABLE -> SYNTAX			WRITE LAYOUT-NAME.

===> ANIL WHY WE DONT USE REWRITE <====

DAY-1:	FILE-1: > CUST-BAL = 1000
    2	FILE-1 > UPDATE ==>  1200
    3:	FILE-1 >  UPDATE >   1300
		...
		..
		..
	N					1200		--> OPEN THIS TODAY -> CAN U TELL ME WHAT WAS THE BAL? -> NO WAY

	UPDATE -> WE LOOSING HISTORY OF INFORMATION..
---
HOW TO UPDATE TO BAL - IN PROJECT:

DAY-1	FILE-1	-> CUST-BAL = 1000 ..
DAY-2    FILE-2  -->  ADD/SUB -> CUST-BAL => 1200		

		FILE-1 => INPUT ->  ONLY READ + COMPUTE UPDATE DATA IN PGM + WRITE --> FILE-2
		1000															 1200
==



--> ENEVIRONMENT DIVISION:-

>> SELECT		-> USED TO TELL  2 THINGS		1. FILE NICK NAME	---> CAN ANYTHING 20 CHAR - SELF EXPLAINED
										2. JCL DD NAME	---> USED TO CONNECT THE FILE -8 CHAR, SAME NAME MUST BE IN JCL.

		MAINFRAME -> DATASET  -->  IBMUSER.T5.ACCT.FILE  --> ACTUAL FILE NAME  --> Q? CAN I CODE THIS NAME IN COBOL PGM.
					PGM NICK NAME		->  ACCT-FILE		-> FILE NICK NAME

COBOL:		SELECT  ACCT-INFILE  ASSIGN  TO ACCTDD01				IN JCL 	//ACCTDD01   DD  DSN=IBMUSER.T5.ACCT.FILE,DISP=SHR
					  A                      B								B						C
							A=B														B=C
												IN EXECUTION
													A=C

				-WHAT ALL OPERATION WE DO ON FILE (A) -> IT WILL EFFECT THE FILE (C)

>> ORGANIZATION ->    USED TO TELL THE TYPE OF THE FILE , HOW THE DATA WILL BE ARRAGNED IN FILE.

	2 KINDS FILE		1. QSAM -> PS FILE				--> SEQUNETIAL		--> 1. ALLOW DUPLICATES   2. NO SORTED ORDER
					2. VSAM -> KSDS CLUSTER			--> INDEXDED			--> 1. NO DUPLICATE    2. SORTED ORDER -BY A KEY FIELDS

			BY DEFAULT -> SEQUENTIAL


>> ACCESS MODE >   USED TO TELL HOW TO ACCESS THE DATA IN THE FILE....

	3 WAYS:		1. SEQUENTIAL  	--> READ THE RECORD 1 BY 1 FROM TO BOTTOM					-> PS & KSDS
				2. RANDOM			--> READ A PARTUCULAR RECORD BASED ON KEY VALUE 	===> KSDS ONLY
				3. DYNAMIC 		->  RANDOM + SEQ								==>  KSDS ONLY


			BY DEFAULT --> SEQUENTIAL


>> FILE STATUS:   THIS IS THE RETURN CODE , WHICH TELL FILE OPERATION RESULT.

		COBOL PGM -> COMPILATION -> JOB SUBMIT?? 		==> MAXCC=0/4/8/12


	01  WS-STATUS-VRAIBALE 		PIC		X(02)  VALUE SPACE.

		--> FILE OPERATION <--
			CHECK FILE STATUS CODE
		
							00 --> SUCCESFULL
							10 --> END OF THE FILE
							21,22,23,24 -->  KSDS ERROR
							--
							39 -> FILE ATTRIBUTE MISMATCH WHEN U OPEN FILE--> COBOL -DETAILS -NOT MATCH- JCL FILE
							--
							41,42,43  --> LOGIC MISTAKE
							--
							35/96 ->  INVALID /MISSED THE DDNAME IN JCL 
							--
							97  --> KSDS INDEX ISSUE.

		== 00 -SUCCESSFUL
		-- ELSE -> ERROR + ABEND THE PGM
======
COBOL CLASS 08:-
--------------------------

PERFORM --		1. SIMPLE PERFORM  - 1 TIME
				2. N TIMES PERFORM -> FIXED LOOP
				3. UNTIL CONDITION -> COND-BASED -VARYING LOOP
				4. PERFORM VARYING -> LATER
				5. PERFORM THRU				-->USED TO EXECUTE MULTIPLE PARAGRAPHS THOGETHER.


EX:		EXECUTE ALL PARA 1 BY 1..

	OPTION-1		PERFORM X-PARA.
			 	SX
				PERFORM A-PARA.
				PERFORM Z-PARA.

	OPTION-2		PERFORM  X-PARA  THRU  Z-PARA.		S1,S2 -S3,S4 - S5,S6
				S7


	X-PARA.
	  S1.
	  S2.

	A-PARA.
	  S3
	  S4.

	Z-PARA.
	  S5
	  S6.


PROJECT POINT:		-> PGM ->  PARA 2 KINDS		1. PROCESS-LOGIC
											2. EXIT

					PERFORM 1000-PARA-NAME  THRU   1000-EXIT.	
					S4

		1000-PARA-NAME.
			S1
			S2
			S3.

		1000-EXIT.  EXIT.		END OF THE PARAGRAPHS   -MOSTLY USED TO SKIP THE PROCESS LOGIN IN 1000-PARA-NAME.
===
HOW TO CODE A PROJECT STYLE PROGRAM::
-----------------

		1. TOP-DOWN APPRAOCH							--< 1. MAIN -> CONTROLER    2. DOWN-PROCESS PARA ->CONTROLLED BY MAIN
		2. MODULAR CODING/PARAGRAPHS CODING.		--> SPLIT A BIG LOGIC -INTO MULTIPLE PARAGRAPHS.


	PROCEDURE DIVISION.
	0000-MAIN-PARA.
		DISPLAY  'PGMNAME STARTED'.

		PERFORM  1000-INITIALIZE-PARA   THRU 1000-EXIT.
		PERFORM  2000-GET-INPUT-PARA    THRU 2000-EXIT.			GET ONLY 1ST RECORD
		PERFORM  3000-PROCESS-PARA      TRHU 3000-EXIT
								UNTIL END-OF-INPUT = 'YES'.   COND TO EXIT THE LOOP WHEN ALL INPUT ARE PROCESSED.

		CLOSE THE FILES.
		DISPLAY  'TOTAL INPUT RECORD  '   WS-IN-REC-CNT.
		DISPLAY  'TOTAL OUTPUT RECORD '   WS-OT-REC-CNT.
		STOP RUN.

	1000-INITIALIZE-PARA.			
			1. INITILIZE ALL NUMBERIC VARA , ALP-NUMERIC   ==MOVE
			2. SET ON/OFF OF THE SWTICH VARIBALE						--> T/F - Y/N - ON/OFF  0/1
			3. GET THE SYSTEM / REQUIRED DATES 
			4. OPEN THE FILES - AS REQUIRED
			5. BUILD THE OCCURS TABLES(LOOK-UP**)
			6. GET 1ST RECORD HERE ONLY..			-- DUPLICATE LOGIC  (SOME DEVELOPER )

	1000-EXIT. EXIT.

	2000-GET-INPUT-PARA.
		1.   READ FILE
		2.   INCRASE THE INPUT VARIBALE COUNTER.

	2000-EXIT.EXIT.

	3000-PROCESS-PARA.
			1. PERFORM  3100-AUDIT-PARA THRU 3100-EXIT	
		----	
			2. PERFORM  3200-LOGIC-PARA THRU 3200-EXIT
			3. PERFORM  3300-CAL-PARA   THRU 3300-EXIT
		---
			4. PERFORM  3400-MOVE-IN-OUT THRU 3400-EXIT
			5. PERFORM  3500-SEND-OUTPUT THRU 3500-EXIT.
		---
			6. PERFORM  2000-GET-INPUT-PARA  THRU 2000-EXIT

	3000-EXIT.  EXIT.

	3200-LOGIC-PARA.
			PERFORM   3210-CHECK-FLD1-PARA  THRU 3210-EXIT
			PERFORM   3220-CHECK-FLD2-PARA  THRU 3220-EXIT

ABOVE POINT -DEVELOPER  --> BELOW -1 POINT -> ANALYST ->SUPT 

	FOLLOW THE NUMBERS..		--> JOB -ABEND -> SPOOL -> SYSOUT ->   ERROR IN 3320-CHK-FL-PARA 

		1. 3320

0000-MAIN -->  1000,
			 2000,
			 3000  -- 3100
					 3200
					 3300 ---  3310-
							  3320-   ABEND HERE	
									3321
									3322
										- 3222-1000

0000 - 3000 - 3300 - 3320	
============================================

CODE A PGM:		--> CREDIT CARD PROGRAM

				1. ACCEPT THE MULTIPLE REC AS INPUT
					2.  A. AUDIT THE DATA ->  1. CHECK IF THE VAIRBALE/INPUT ARE GIVEN OR NOT
					    B. REMOVE THE DUPLICATE'S
					   			 C. CAL ->  DISPLAY ONLY THOSE CARD -WHOSE CARD DUE AMT -IS > 75 % OF CARD-LIMIT
															10000(C-LIMIT) -> 5000 DUE AMT -> NO DISPLAY
																		->  8000 DUE AMT -> DISPLAY
											OR
								D. I WANT TO DISPLAY ONLY THOSE CUSTOMER -WHO'S CARD EXPIRES IN 1 MONTHS

				3. IF VALID DATA -> OUTPUT

	VARIABLE ->   1. DATA VARIBALE		-- EASY - INPUT FILE - DEFINE THE VARIABLE
				2. LOGIC VARIBALE	--  DEVELOPER SKILL

						1. LOOPING VARIBALE
						2. VALIDATION SWTICH 
						3. INPUT COUNT  - OUTPUT COUNT 
						4. DATE VARIABLE
						5. HOLD DATA VARIBALE
						6. MORE ..


REMOVE THE DUPLICATE:
						--> DATA MUST BE SORT ORDER.
1	C1111
2	C2222
3	C2222
4	C3333
5	C3333				Q ->1-5 -> WHICH ARE THE DUPLICATE ->  3 & 5

	
	CARD-NUMBER	=  WS-CARD-NUMBER-HOLD
1		C1111		SPACE			-> FALSE	--> DISPLAY THE RECORD -C1111 -  MOVE C1111 TO HOLD
2	     C2222		C1111			-> FALSE	->  DISPLAY THE RECORD -C2222 -  MOVE C2222 TO HOLD
3		C2222		C2222		-TURE - DUPLICATE -SKIP
4		C3333		C2222			-> FALSE	->  DISPLAY  THE RECOERD -C3333 - MOVE C3333 TO HOLD
5		C3333		C3333		-TRUE -> DUPLICATE SKIP

===
006800            IF  WS-VALID-INPUT = 'Y'                                  
006810              IF CARD-NUMBER OF CARD-DETAILS-IN = WS-CARD-NUMBER-HOLD 
006900                PERFORM  340-MOVE-DISPLAY-PARA  THRU 340-EXIT         
006910                MOVE CARD-NUMBER OF CARD-DETAILS-IN TO                
006920                                    WS-CARD-NUMBER-HOLD               
006930              ELSE                                                    
006940                DISPLAY 'DUPLICATE RECORD ' CARD-DETAILS-IN           
006950              END-IF                                                  
007000            END-IF.                                                   

====

CARD-LIMIT  >  10000
CARD-DUE-AMT -> 8000
--
	>>75%?	WHAT IS THE 75% OF CARD-LIMIT??

			COMPUTE  WS-75-CARD-LIMIT   = CARD-LIMIT * .75
						7500				10000

			IF  CARD-DUE-AMT >  WS-75-CARD-LIMIT 
				DISPLAY
			ELSE
				IGNORE
			END-IF.

====

















===============================================================
COBOL CLASS 07:-
===============================
Control Sequence Verbs                 -              Perform ,STOP RUN, GOBACK, EXIT, EXIT PROGRAM, GOTO 
--
MOVE - IF - PERFORM -- WE NEED THESE	
	MOVE -> PASSING DATA B/W VARIBALE
	IF	-> LOGIC - BUSINESS COND / RULES / FILTER/ VALIDATION.
	-PERFORM.

CONTROL SEQ FLOW:  -- TO COME OUT OF CODE
							
STOP RUN			--> USED TO PASS THE CONTROL OUT OF THE COBOL PGM , THE CONTROL WILL GO BACK TO OS ONLY.	--> ONLY MAINPGM(PGMA)
EXIT PROGRAM		--> USED TO PASS THE CONTROL OUT OF THE COBOL SUBPGM, SEND CONTOL BACK TO MAINPGM			--> ONLY SUBOGM(PGMB)
GOBACK			--> USED TO PASS THE CONTROL OUT OF THE COBOL PGM -- CAN BE USED IN ANYPGM.. SEND CONTROL TO BACK FROM WHERE IT RECEVIED.

--> CODE A COBOL PGM ,COMPILE JOB , EXECUTE LOAD - OUTPUT <--

RUNJCL JOB -> SUBMIT -->  SYSTEM WILL EXECUTE --> NOTIFICATION MAXCC=0/ABEND

JCLJOB ->  SUBMIT --> JES (JOB ENTRY SUB-SYSTEM)	-CHECK THE JCL CODE -MISTAKE -> FAIL - JCL ERROR

JCLJOB -> SUBMIT -> JES ->  CHECK CODE -> NO ERROR -> PICK LOAD (EXEC + STEPLIB) --> OS -EXECUTING LOAD -STOP RUN -- OS - JES - NOTIFY -MAXCC=00

	JCLJOB -SUB -JES -LOAD PGMA - OS -EXECUTE PGMA(STOP RUN) - OS - JES - MAXCC=00

	SUBPGM:	- PGM CALLED BY ANOTHER PGM

		PGMA -> CALLING - PGMB
	MAINPGM              SUBPGM

>JCLJOB - SUB -> JES -> LOAD(PGMA) --> OS -> PGMA --- PGMB(STOP RUN) --OS --> INCORRECT - PGMA IS IN THE SYSTEM WAITING

>JCLJOB - SUB -> JES -> LOAD(PGMA) --> OS -> PGMA --- PGMB(EXIT PROGRAM) --OS --> INCORRECT - PGMA IS IN THE SYSTEM WAITING

>JCLJOB - SUB -> JES -> LOAD(PGMA) --> OS -> PGMA --- PGMB(GOBACK)  --> PGMA(GOBACK)  -- OS  -> JES --> NOTIFY = MAXCCC/ABEND


=== CONTROL THE PGM FLOW -WITHIN*:-
---

	1. PERFORM	-->     USED TO PASS THE CONTROL TO PARAGRAPH FOR EXECUTION
	2. GOTO		-->	    USED TO PASS THE CONTROL TO PARAGRAPHS FOR EXECUTION
	3. EXIT		-->  END THE PARA -EXIT THE PARA STATEMENT..

PERFORM  vs GO TO:

	PERFORM  --->  TO PROCESS A LOGIC ON A RECORD..
				--> IT CAN BE USED TO CREATE THE LOOP
	--
	GO TO	-->  TO SKIP A LOGIC FOR A RECORD.
				--> THIS IS NOT FOR LOOP
==
BOOK TOPIC:
-----
PERFORM :		2 TYPES		1. INLINE PERFORM 			2. OUTLINE PERFORM

	>>INLINE PEROFRM  -> THE STATEMENT OF LOGIC ARE CODED IN  B/W  PERFORM - END-PERFORM 
							==> THE LOGIC CANNOT BE EXECUTED FROM OTHER PART OF THE PGM..
							==>  IF I HAVE SAME CODE TO BE EXECUTED IN REPETITION.


	SYNTAX:	1000		PERFORM 
			1001			S1
						S2
						S3
					END-PERFORM.

			2000  -> U NEED S1,S2,S3  -> CODE AGAIN


	>> OUTLINE PERFORM ->  THE STATEMENT OF LOGIC ARE CODED IN AN PARAGRAPH, CONTROL IS PASSED TO IT.
						==> THE LOGIC (PARA) CAN BE EXECUTED FROM ANYWHERE IN THE PGM

	
	SYNTAX:	1000		PERFORM   X-PARA.

1500		X-PARA.
1501			S1
1502			S2
			S3.

	
		2000 -> 	PERFORM  X-PARA.


PERFORM -- LOOP:

	EXECUTE A LOGIC -		1. EXECUTE ONLY 1 TIME
						2. N TIMES (FIXED)
						3. CONDITION (VARYING)
	
INLINE PERFORM:
				1.  	 	PERFORM
							S1
							S2
						END-PERFORM.

				2.  	 	PERFORM  N TIMES				N - 2,3,4..
							S1
							S2
						END-PERFORM

				3. 		PERFORM  UNTIL CONDITION-IS-TRUE**		--> USED WHEN WE DONT KNOW THE LOOP COUNT.
											COND - TURE -> LOOP EXIT
												   FALSE -> LOOP CONTINUE


OUTLINE PERFORM
		
			1.  PERFORM  X-PARA.
				S4

			1.  PERFORM X-PARA  N TIMES.			N -2,3,4..
				S4

			3.  PERFORM  X-PARA  UNTIL COND-IS-TRUE
				S4
	
	X-PARA.
		S1
		S2
		S3.

			EX:		01   WS-I		PIC		9(02) VALUE ZERO.

					PD.
						MOVE  +1   TO   WS-I.				WS-I = 1
						PERFORM   UNTIL  WS-I > 10			1 > 10(F)	    2>10(F)  3>10, 4>10... 9>10(F)	 10 > 10	  11>10(T)
							DISPLAY  WS-I					1		    2					9		 10
							ADD +1   TO  WS-I			1+1 =2		 1+2=3				 1+9=10		1+10=11
						END-PERFORM.
						SX						-> O/P -> 1 2 3... 10
														 


			EX:		01   WS-I		PIC		9(2) VALUE ZERO.

					PD.
						MOVE  +1   TO   WS-I.				WS-I = 98
						PERFORM   UNTIL  WS-I > 100			98>100 (F)  99>100		00> 100 (F)   1>100(F) 2>(F).... 00>100
							DISPLAY  WS-I					98		   99		00
							ADD +1   TO  WS-I			1+98=99		 1+99 = 1-00  1+0 =1
						END-PERFORM.
						SX						
										O/P: -  1-99?? 1-100 --> INFINTE LOOP

GOOD DEVELOPER -->   NOT ABT HOW START THE LOOP  -> WHEN TO EXIT THE LOOP**

			EX:		01   WS-I		PIC		9(2) VALUE ZERO.

					PD.
						MOVE  +1   TO   WS-I.			
						PERFORM   UNTIL  WS-I < 10		1< 10 (T)-EXIT
							DISPLAY  WS-I				
							ADD +1   TO  WS-I			
						END-PERFORM.
						SX						 
										O/P: -  NOTHING
>> PEROFRM VARYING * PERFORM THRU*

			



























 IF & Evaluate Statement – Continue & Next Sentence  
=====

HOW TO CODE AN CONDITIONAL STATEMENT (IF/EVALUATE):

				1. ALL POSSIABLE VALUE OF THE DATA VARIABLE MUST BE ON THE CONDITION..  IF GENDER = MALE    AND IF GENDER = FEMALE
 				2. ELSE -> USE IT FOR INVALID DATA		- HANDLE THE DATA	  (MAIL.. )
							INVALID ->  2 WAYS TO HANDLE
														1. IGNORE IT --> MOVE THE ERROR DATA TO AN ERROR FILE , CORRECT THEM LATER
														2. HANDLE IT --> DISPLAY + ABEND THE PGM  --> CORRECT IT NOW ONLY.


				APPLICATION-A --> PASS DATA --> APPLICATION B (PROCESSING/ADD MORE DETAILS) ---> APPLICATION-C
											===YOU ARE HERE ==
												1MILLION -> FEW RECORD ARE INCORRECT?? --> NO > ERROR FILE (SEND IT BACK TO APP-A)
												1MILLION -> PROCESS -NEW DATA - ISSUE --> ABEND THE PGM - CORRECT DATA - RERUN.

				3. PERFORMANCE --> HIGHER OCCURANCE OF THE VALUE MUST BE 1ST CONDITION..


Evaluate --> MUST BE MULTIPLE POSSIABLE VALUE..
															Evaluate
											Evaluate TRUE						Evaluate VARIABLE

IF  GENDER = MALE									Evaluate TRUE						Evaluate GENDER
	DO THIS										WHEN GENDER = MALE					WHEN MALE
ELSE													DO THIS							DO THIS
IF  GENDER = FEMALE								WHEN GENDER = FEMALE				WHEN FEMALE
	DO THE											DO THIS							DO THIS
ELSE												WHEN OTHER						WHEN OTHER
    ERROR+ABEND										ERROR + ABEND						ERROR + ABEND
END-IF											END-Evaluate.						END-Evaluate.
END-IF


IF & Evaluate -> CONDITIONAL STATEMENT -> THEY DECIDE WHAT LOGIC TO RUN ,IN CASE IF CONDTIION TRUE/FALSE
	--
CONTINUE & NEXT SENTENCE..  -> DO NOTHING STATEMENT 

	>> CONTINUE  ->  THE CONTROL WILL JUMP TO NEXT STATEMENT -AFTER NEAREST END-IF
	
	>> NEXT SENTENCE -> THE CONTROL WILL JUMP TO NEXT SENTEANCE -AFTER NEAREST . (DOT).


EX:			S1
			IF CONDITION-1
				S2
				S3
				IF CONDITION-2
					-->NOTHING		CONTINUE		OR   NEXT SENTENCE
				ELSE
					S4
					S5
				END-IF
				S6
			ELSE
				S7,S8
			END-IF.
			S9								CONTINUE: -	S6		NEXT SENTENCE:- S9



COBOL CLASS 06:-
Conditional Statements                 -              IF & Evaluate Statement – Continue & Next Sentence  
=====
 IN COBOL ->  2 THINGS		1. CALCAUTION    2. CONDITION CHECK  1. FILTER CONDITION  2. DATA VALIDATE  3. DATA COMPARE 

	2 STATEMENT		1. IF CONDITION -TODAY		2. EVALUATE STATEMENT -TOMORROW.

==> IF STATEMENT:  - CONDITIONAL STATEMENT , CHECK SOME VALUE AND CONTROL THE EXECUTION FLOW.

	SYNTAX:

	SIMPLE IF:		IF CONDITION
						T- S1,S2
					END-IF.

	IF-ELSE 			IF CONDITION
						T- S1,S2
					ELSE
						F- S3,S4
					END-IF.

MULTIPLE POSISABLE VALUE :		1. IF-ELSE LADDER  	 OR   2. EVALUATE

	IF-ELSE LADDER:										A-10
						IF COND-1					IF A > 5
							T-S1,S2
						ELSE
						IF COND-2					IF A > 6
							T-S3,S4
						ELSE
							F-S5,S6
						END-IF
						END-IF.
						S7					 COND-1 -> TRUE -> S1,S2,S7
											 COND-2 -> TRUE -> S3,S4,S7
											COND-1 & 2 - TRUE --> 	S1,S2,S7
							
	->
	NESTED-IF				IF CONDITION-1
							S1
							S2
							IF CONDITION-2
								S3
							ELSE
								S4
							END-IF
						ELSE
							S5
						END-IF.

	--> IN B/W IF & END-IF  --> DO NOT USE ANY DOT (. -IMPLICT TERMINATOR)
	--> TRY TO CODE EQUAL NUM OF - IF & END-IF.
==
 == ABOVE IS BOOK POINT <==  ==> BELOW IS THE PROJECT POINT <==
===
CODE A SIMPLE  --  TO ACCEPT CUSTOMER DETAILS --> BASED ON GENDER -> ASSIGN A CUSTOMER-TITLE AS BELOW..
			
				1. ACCEPT CUST-DETAILS
					2. LOGIC  ->   GENDER -- MALE ->  TITLE -MR. ANIL
										FEMALE ->  TITLE -MRs. RANI
				3. DISPLAY THE DETAILS

		ID DIVISION.
		PROGRAM-ID. CUSTPGM1.
		AUTHOR. NAME.
		DATE-WRITTEN. TODAY.

		ENVIRONMENT DIVISION.
		INPUT-OUTPUT SECTION.
		FILE-CONTROL.

		DATA DIVISION.
		FILE SECTION.
		WORKING-STORAGE SECTION.
		01 CUST-DETAILS-IN.
			03 CUST-ID		PIC		X(05).
			03 CUST-NAME		PIC		X(10).
			03 CUST-GENDER	PIC		X(10).

		01 CUST-DETAILS-OUT.
			03 CUST-ID		PIC		X(05)  VALUE SPACE.
			03 CUST-TITLE		PIC		X(03)  VALUE SPACE.
			03 CUST-NAME		PIC		X(10)  VALUE SPACE.
			03 CUST-GENDER	PIC		X(10)  VALUE SPACE.

		PROCEDURE DIVISION.
		000-MAIN-PARA.
S1			DISPLAY  'CUSTPGM1  STARTED'.

S2			MOVE 	SPACE   TO	CUST-ID		OF CUST-DETAILS-IN
								CUST-NAME		OF CUST-DETAILS-IN
								CUST-GENDER	OF CUST-DETAILS-IN.

S3			ACCEPT  CUST-ID OF CUST-DETAILS-IN
			ACCEPT  CUST-NAME OF CUST-DETAILS-IN
			ACCEPT  CUST-GENDER OF CUST-DETAILS-IN.								<< MALE						

S4			IF  CUST-GENDER OF CUST-DETAILS-IN = 'MALE'						MALE = MALE (T)					MAIL = MALE (F)
					MOVE  'MR'   TO   CUST-TITLE OF CUST-DETAILS-OUT				>> MR
			END-IF.

S5			IF  CUST-GENDER OF CUST-DETAILS-IN = 'FEMALE'						MALE = FEMALE (F)					MAIL = FEMALE (F)
					MOVE  'MRs'  TO   CUST-TITLE OF CUST-DETAILS-OUT
			END-IF.

S6			MOVE   CUST-ID OF CUST-DETAILS-IN  TO
							CUST-ID OF CUST-DETAILS-OUT
			MOVE   CUST-NAME OF  CUST-DETAILS-IN TO
							CUST-NAME OF CUST-DETAILS-OUT
			MOVE   CUST-GENDER OF CUST-DETAILS-IN  TO
							CUST-GENDER OF CUST-DETAILS-OUT.	
			
S7			DISPLAY  'CUSTOMER DETAILS WITH TITLE '   CUST-DETAILS-OUT.				MR ANIL
S8			STOP RUN.

-COMPILE THE PGM --> LOAD - 

//JOBNAME  JOB NOTIFY=&SYSUID
//STEP1   EXEC  PGM=CUSTPGM1
//STEPLIB   DD  DSN=IBMUSER.T5.LOAD,DISP=SHR
//SYSPRINT  DD  SYSOUT=*
//SYSOUT    DD  SYSOUT=*
//SYSIN   DD *
C1234													C1236								C1237
ANIL 													RANI									ANIL
MALE														FEMALE								MAIL
/*
//				O/P:  C1234  MR  ANIL  MALE					O/P:   C1236 MRs RANI  FEMALE			O/P -> C1237      ANIL  MAIL

	==> QUESTION ->  IF THIS PGM -CAN I USE THIS PGM FOR MY PRODCUTION: -

PGM P1 >   CHECK EACH RECORD  (MALE - FEMALE ) -> 2 CONDITION

		10 RECORD INPUT --->   PGM - 20 CONDITION 
			1 MILLION 		PGM - 2 MILLION CONDITION

	
	PERFORMANCE	-> 	 1. POOR    2. GOOD   3. BEST		==> P1 ? POOR
========================
CUSTPGM2:
		PROCEDURE DIVISION.
		000-MAIN-PARA.
			DISPLAY  'CUSTPGM1  STARTED'.

			MOVE 	SPACE   TO	CUST-ID		OF CUST-DETAILS-IN
								CUST-NAME		OF CUST-DETAILS-IN
								CUST-GENDER	OF CUST-DETAILS-IN.

			ACCEPT  CUST-ID OF CUST-DETAILS-IN
			ACCEPT  CUST-NAME OF CUST-DETAILS-IN
			ACCEPT  CUST-GENDER OF CUST-DETAILS-IN.								<< MALE					<< FEMALE	    	<< MAIL

			IF  CUST-GENDER OF CUST-DETAILS-IN = 'MALE'						MALE = MALE =T				FEMALE = MALE   MAIL = MALE
					MOVE  'MR'   TO   CUST-TITLE OF CUST-DETAILS-OUT				MR
			ELSE
					MOVE  'MRs'  TO   CUST-TITLE OF CUST-DETAILS-OUT											MRs			MRs
			END-IF.

			MOVE   CUST-ID OF CUST-DETAILS-IN  TO
							CUST-ID OF CUST-DETAILS-OUT
			MOVE   CUST-NAME OF  CUST-DETAILS-IN TO
							CUST-NAME OF CUST-DETAILS-OUT
			MOVE   CUST-GENDER OF CUST-DETAILS-IN  TO
							CUST-GENDER OF CUST-DETAILS-OUT.	
			
			DISPLAY  'CUSTOMER DETAILS WITH TITLE '   CUST-DETAILS-OUT.
			STOP RUN.

-==> MALE  ->  MR ANIL			,,  FEMALE	 --> MRs RANI					MAIL -->   MRs ANIL

PGM P2 ->    FOR EACH RECORD - IT CHECKS ONLY 1 CONDITION

		10 RECORD -- 10 CHECK
			1M	--  1 MILLION

PERFORMANCE ->  P2	->		1. POOR		2.  GOOD		3. BEST		==>    BEST 


				LOGIC vs PERFROMANCE  -->  CHOOSE ANY 1-->  LOGIC  - PERFORMANCE

																		WHICH ONE U CHOOSE
	P1 -->  2 CONDITION	-> PERFORMANCE -POOR		-> O/P -> NO TITLE			ANIL  -THIS IS UR STATEMENT
	P2 -->  1 CONDITION	-> PERFORMANCE -BEST		-> O/P -> MRs ANIL			MRs ANIL -- THIS IS UR STATEMENT

		
CUSTPGM3:

		PROCEDURE DIVISION.
		000-MAIN-PARA.
			DISPLAY  'CUSTPGM1  STARTED'.

			MOVE 	SPACE   TO	CUST-ID		OF CUST-DETAILS-IN
								CUST-NAME		OF CUST-DETAILS-IN
								CUST-GENDER	OF CUST-DETAILS-IN.

			ACCEPT  CUST-ID OF CUST-DETAILS-IN
			ACCEPT  CUST-NAME OF CUST-DETAILS-IN
			ACCEPT  CUST-GENDER OF CUST-DETAILS-IN.

			IF  CUST-GENDER OF CUST-DETAILS-IN = 'MALE'
					MOVE  'MR'   TO   CUST-TITLE OF CUST-DETAILS-OUT
			ELSE
			IF  CUST-GENDER OF CUST-DETAILS-IN = 'FEMALE'
					MOVE  'MRs'  TO   CUST-TITLE OF CUST-DETAILS-OUT
			ELSE
				DISPLAY 'INVALID GENDER INPUT '   CUST-DETAILS-IN
				CALL  WS-ABENDPGM
			END-IF
			END-IF.

			MOVE   CUST-ID OF CUST-DETAILS-IN  TO
							CUST-ID OF CUST-DETAILS-OUT
			MOVE   CUST-NAME OF  CUST-DETAILS-IN TO
							CUST-NAME OF CUST-DETAILS-OUT
			MOVE   CUST-GENDER OF CUST-DETAILS-IN  TO
							CUST-GENDER OF CUST-DETAILS-OUT.	
			
			DISPLAY  'CUSTOMER DETAILS WITH TITLE '   CUST-DETAILS-OUT.
			STOP RUN.

								LOGIC
INPUT->1	-->  MALE  ->  MR ANIL
	  2. =>  FEMALE ->  MRs RANI
	  3. >   MAIL	-> 	-ERROR  ->  ABEND THE PGM


	AS PER CUSTPGM3 -->  ALL MALE RECORD -.1 TIME		= ALL FEMALE -> 2 TIME CHECK

		10 RECORD INPUT ->    4 MALE		--> 4 TIME
							6 FEMALE		--> 12 TIME		=> 16 TIMES

							6 MALE		=   6 TIME
							4 FEMALE		=   8 TIME		==> 14 TIMES

	
	P1 ->  20 CONDITION			--> POOR
	  P3 ->  14-16 TIMES			--> GOOD
	P2 >   10 CONDITION			--> BEST


	100 STUDENT		--> 90 PASSED			-  90 TIMES
					    10 FAILED			-  20 TIMES		==> 110 CHECK

					->	10 FAILED		--> 	10 TIME
					->   90 PASSED	--> 180				==> 190 CHECK


















COBOL CLASS 05:-
============================

	2 POINTS  - I WANT SHOW 2 POINT : 	1. HOW TO COMPILE A PGM IN PROJECT -- USING -TOOL ->  MAKE CHANGES - F3 -ENTER - SUBMIT COMPILE JOB
									2.  3 STATEMENT -  MOVE IF PERFORM

	PROJECT - PGM -> 	APPLICATION-A :   ASSUME -> U HAVE 100 PGM -> AVG -> 1000-3000

					LESS THAN 10 <  ABOVE 3000 LINES
					LES THAN 15 <  BELOW 1000 LINE
				----		
					75 PGM ->  B/W  >1000   <3000

	COBOL LANG --> 	WE HAVE 10-15 STATEMENT TO USE (ACCEPT , DISPLAY..COMPUTE)

	WE HAVE 15 STATEMENT -- HOW TO CODE  1000 LINES OF PGM		= REPETITION OF THE STATEMENT

			1 STATEMENT -> 100 TIMES -> 100 LINE OF CODE
			15 STATR	--->  100 TIME  -> 1500 LINES OF CODE.

OUT OF 15 STATEMENT -> 3 STATEMENT MAKE THE 75% OF THE PGM

			1. MOVE    2. IF STATEMENT  3.  PERFORM
================================================================================================
Data Movement Verbs                    -              Simple Move, Move with Of clause, Group Move & CORR	

MOVE  -->   USED TO PASS THE DATA TO A VARIABLE..

		> PASS -> CONSTANT TO A VAIRBALE 	->  MOVE   10   TO VARA.
		> PASS -> VARIABALE TO ANOTHER VARIABLE >  MOVE  VARA  TO  VAR-B.

EX:		MOVE  A  TO B.		A - 10 , B- 20  ---AFTER MOVE --  A-10, B-10
							A - 12 , B- 03  ---AFTER MOVE --  A-12, B-12

==>
WHY DO WE USE MOVE IN MY PGM:

	1. INITILIZE THE VARIALE IN PROCEDURE DIVISION
	
		-> MOVE 		 NUMERIC DATA		-> MOVE  ZERO   TO VARA.
						ALP-NUM		-> MOVE  SPACE  TO VARB.
					SWTCIH VARI		-> MOVE 'Y'    TO  VARC.  --> MOVE  TRUE  TO VARX.


	2. MOVING THE DATA  B/W  INPUT - OUTPUT VARIABLE.

		DATA PROCESSING ->   WE WILL DEFINE VARIBALE -> INPUT
							AND ALOS WE DEFINE VAIRBALE -> OUTPUT

	INPUT -FILE->  -> GET THE DATA -> PGM (STORE IN INPUT VARIABLE <<APPLY BUSINESS RULES>> --> OUTPUT VARIABLE ))SEND -- FILE


==> BEHAVIOURS..:  MOVE??

	NUMEIRC DATA ->  RIGHT JUSTIFICATION

	EX:
			MOVE 	100		TO		VAR-A.		PIC	9(03).  NO ISSUE ->	100
			MOVE		100		TO		VAR-A.		PIC 	9(04).  NO ISSUE ->	0100
			MOVE		100		TO		VAR-A.		PIC	9(02).	DATA TRUCATION	-> 1-  00


	ALP-NUMERIC DATA :  LEFT JUSTIFICATION

	EX:
			MOVE 	'ANIL'	TO		VAR-B.		PIC	X(04).	NO ISSUE -> ANIL
			MOVE		'ANIL'	TO		VAR-B.		PIC	X(05).	NO ISSUE => ANILb    b - BLANK SPACE
			MOVE		'ANIL'	TO		VAR-B.		PIC	X(03).	DATA TRUCATED >   ANI - L 


	DECIMAL ->  POINT JUSTICATION
	EX:

			MOVE   123.456		TO		VARC.		PIC	  9(02)V9(02).		O/P ->  23.45


	>> HOW TO HANDLE DATA TURCATION OVER MOVE STATEMENT:-  1 WAYS -> GIVE REQUIRED/MORE SPACE TO TARGET VARIABLE.
						
		ON SIZE ERROR -> ONLY FOR AIRTHEMETIC OPERATION -> COMPUTE , ADD , SUB
---		
==> TYPES OF MOVE STATEMENT
---
1. SIMPLE MOVE		--> VAIRABLE SHOULD BE UNIQUE (SRC VARA NAME - TARGET VAR NAME -SHOULD BE DIFF)

 VALID EX:		MOVE  A  TO  B.
				MOVE 10  TO A.
				MOVE SPACE TO  A, B, C.
				MOVE  10  TO A,B,C.

 INVALID EX:		MOVE   A   TO A.		=ERROR IN COMPILATION.

 VARA-  9(03).
 VARB-  X(03).								VALID ?
				1. MOVE  VARA   TO  VARB.		 YES
				2. MOVE  VARB   TO  VARA.		 YES
	
	CHECK THE DATA -> GOOD AND BAD
	
				VARA -> 123	->  MOVE VARA  TO VARB.  VALID.
				VARA -> 1.2 ?? NO (IF U HAVE)  -> MOVE  VARA  TO VARB --> VALID

				VARB -> 123	-> MOVE  VARB  TO VARA.	 VALID
				VARB -> 1.2?? YES  -> MOVE   VARB  TO  VARA -> ABEND S0C7 -> BAD DATA TO NUMERIC


2. GROUP MOVE:
				01 CALIM-DETAILS-IN.					01 CLAIM-DETAILS-OUT.
					03 CLAIM-NUMBER						03 CLAIM-NUMBER
					03 CLAIM-AMT							03 CLAIM-AMT

		> MOVE THE DATA B/W 2 GROUP:> THEY MUST IDENTICAL GROUP..
							
						1. SAME NUM OF VAIRBALE
						2. SAME SEQ 
						3. SAME TYPE & SIZE

			EX:  MOVE   CLAIM-DETAILS-IN 		TO CLAIM-DETAILS-OUT.

		> GROUP -CORR MOVE  -> USED WHEN THE GROUP VARIBALE SEQ IS NOT MATCHING..

			01  DATE-YMD.				01  DATE-DMY.
				03 YYYY  					 DD
				03 MM					 MM
				03 DD					 YYYY

			GROUP MOVE  ->  MOVE  DATE-YMD  TO DATE-DMY.		> WRONG MOVE 
			GROUP + CORR ->  MOVE  DATA-YMD CORR TO DATE-DMY.	-->  MATCH MOVE ->  DD-DD , MM-MM, YYYY-YYYY

	>> GROUP/CORR MOVE ARE NOT PREFFERED IN THE PROJECT.

3.
MOVE WITH OF**

				01 CLAIM-DETAILS-IN.					01 CLAIM-DETAILS-OUT.
					03 CLAIM-NUMBER						03 CLAIM-NUMBER
					03 CLAIM-AMT							03 CLAIM-AMT


I WANT TO MOVE THE DATA >   1. GROUP MOVE -> DONT USE
						2. SIMPLE MOVE			-> MOVE CLAIM-NUMBER  TO CLAIM-NUMBER??   NO -INVALID  -COMPILATION
		
	3. MOVE OF**		MOVE CLAIM-NUMBER OF CLAIM-DETAILS-IN
								TO
						CLAIM-NUMBER OF CLAIM-DETAILS-OUT.

	ANY TIME - IF U HAVE SAME VARIBALE NAME IN 2/MORE DIFF GROUP.. THEN  WE MUST USE OF CLAUSE AND POINT THE GROUP NAME.

				ACCEPT CLAIM-NUMBER>> INVALID 		-- ACCEPT CLAIM-NUMBER OF CLAIM-DETAILS-IN << VALID
				DISPLAY CLAIM-NUMBER > INVALID		-> DISPLAY CLAIM-NUMBER OF CLAIM-DETAILS-OUT.

===
1. DISPLAY  - HELLO
2. DEFINE -> CAL 
3. ASSIGNEMENT:		CODE A SIMPLE COBOL PGM ->  2 GROUP (IN-OUT)
							-> DEFINE 10 VARIBALE << ONLY BUSINESS DATA VARIABLE..  ONLY CLAIM DATA.
										
									CLAIM-STATUS  -> BUSINESS VARIBALE
									CUSTOMER-NAME -> NO -CUSTOMER DATA

									CLAIM-TYPE	-> BUSINESS VAIRBALE
									CONTACT NUMBER -> CUSTOMER DATA
							-> ACCEPT THEM INPUT GROUP VARI
							-> MOVE THEM TO OUTPUT 
							-> DISPLAY THOSE 10 VARIBALE.
	O/P
			****CLAIM DATA *********
			1. CLAIM NUMBER:   123445
			2. CLAIM TYPE	:     MEDICAL
			3. CLAIM STATUS :   APPROVED
				...		


===

COBOL CLASS 04:-
--------------------
PRACTICAL IN MAINFRAME -->   DIVISION - SECTION - PARAGRAPHS -- VARIABLE -- VALUE -- ACCEPT -- DISPLAY -(COMPILER SETUP)

==> LETS CODE A SIMPLE PGM ->  JUST TO ADD 2 NUMBER - DISPLAY THE RESULT.

			10 + 20 => 30

	--> 1000/2000 LINE OF PGM -> CODE  AS FRESHER/NEW DEVE ->  I WILL MAKE ERROR
						  -> CODE   AS EXP /EXPERT		-> I WILL MAKE ERROR

COMPILE -> PGM -> MAXCC=8/12 	-> ERROR -> HOW TO SOLVE THE ERROR

		OPTION	1. GOTO PGM , CHECK LINE BY LINE -> FIND MISTAKE -- CORRECT THEM - RE-COMPILER			-- NEVER DO THIS..
				2. GOTO SPOOL -> CHECK THE SYSPRINT - SEE THE MISTAKE - CORRECT THEM - RE-COMPILER		-- ALWAYS..
	
		HOW TO GOTO SPOOL /NAVIGATE FAST.
				1. START COMMAND - TO OPEN NEW SESSION  ,,,  USE =F9 - SWAP B/W SCREEN

				COMPILER ERROR -> 	 	-I  > INFORMATIVE -> IGNORE
									-W  > WARNING    -> IGNORE
									-E  > ERROR
									-S  > SEVER ERROR
				
		IGYDS1082-E A period was required.		--> DOT IS MISSING IN PREVIOUS/BEFORE STATEMENT
		IGYPS2010-E Procedure-name "000-MAIN-PARA" was found in area "B" 	-->
		IGYPS2121-S "TOTLA" was not defined as a data-name. 		--> VARIBALE IS NOT FOUND   1. SPELLING MISTAKE   2. U FORGOT DEFINE.

					8-11 > AREA=A => DIVISION ,SECTION , PARA
					12-72 > AREA-B -> STATEMENT.

2ND POINT**
JCL ERROR *(COMPILER JOB , RUN JCL JOB) --> ERROR ->   'JCL ERROR'		--> SPOOL -> CHECK - JESYSMSG DD LIB

3RD POINT**
				PGM   & DATA -> WHAT WILL BE CHANGING DAILY  -> DATA

-ADDPGM01 ->  I HAVE ADDED  -> 10,20 > 30
		NOW -> ADD - 30,40				1. EDIT THE PGM  2. COMPILE   3. EXECUTE   4. SEE THE RESULT.
		NOW -> ADD - 25 45				

		=AM I DOING IT CORRECT  ->   NO -->  WE CANNOT EDIT THE PGM , EACH TIME DATA CHANGES.


			-> THE PGM  & DATA SHOULD BE SEPERATED..

4TH POINT -MAIN POINT:-
---

		NUM1   PIC  9(02)	 00-99		> 50
		NUM2   PIC  9(02)	 00-99		> 50
		TOTAL  PIC  9(02)  00-99	>   100		-2 DIGIT ARE ALLOWED -> NUMERIC -> RIGHT 	1-	00

	=ANIL IS SUPT --> APPLICATION -A ->  DAILY  - 500 JOB WILL EXECUTE (NIGHTLY BATCH CYCLE)

				DAY-1 -> ALL 500 JOB -> MAXCC=00  ->  WILL ANIL OPEN ANY JOB LOGS? --> NO
				DAY-2 => ALL 500 JOB -> MAXCC=00				OPEN??				  NO
					-
				DAY-X	-> 1 JOB FAILED , 499 ARE SUCCESFUL		->    WILL OPEN THE LOG ??  YES..

		--> ABOVE -> ANIL WILL OPEN THE LOG'S ONLY WHEN THE JOB FAILED

	COBOL ->  CANNOT SAY ERROR -> WHEN DATA IS GETTING TRUCATED..

==> ADDITION ->  I WILL TELL U 3 SOLUTION  -> CHOOSE THE BEST OPTION..

		1. DATA IS TRUCATED - 
		2.  MAXCC=00 -- THIS IS ALSO AN ISSUE.

ON SIZE ERROR
		1.   DISPLAY..					    > DISPLAY  'ERROR IN COMPUTE'	>>  SHALL WE USE THIS OPTION?  	NO.NO,NO
		2.   RETURN-CODE  (WE DONT USE PROJECT)	>  MOVE   3200  TO RETURN-CODE	>>  SHALL WE USE THIS OPTION?	YES..
		3.	ABEND THE PGM**
								01  WS-ABENDPGM   PIC   X(08)   VALUE  'ABENDPGM'.
								CALL WS-ABENDPGM.



	Q:		PGM ->
						S1
						S2
						S3
						S4	--> DATA PROCESS -> DATA GOT CORRUPTED.  ?  SHALL I CONTINUE THE PROCESS - EXECUTE S5,S10???
						...
						S10
					

		PGM ->     STOP RUN -> SUCCESSFUL EXECUTION
				  ABEND THE PGM -SOME TIMES  --> DATA ISSUE


 -->  A --> +1		B  ->  +2 	--> A + B ==> C  = +3

		S9(02)  -> 20	--DISPLAY 	-> SPOOL  --> NOT SHOW  =>  +20
												SHOW  ->  2{		{ +0
				  21										 2A
				  22										 2B

			S9(02) -> HOW MANY BYTES ALLOCATED? >   2 BYTES

					+33		-->  3C	
























COBOL CLASS 03:- INPUT-OUTPUT STATEMENT:-
================

DEVELOPER:		1. CODE THE PGM		2. COMPILE		3. CODE RUNJCL + EXECUTE

	> CODE THE PGM:	>STEP		1. GET THE DATA AS INPUT
								2.		-APPLY THE BUINESS LOGIC + CONDITION + CAL
								3. SEND THE DATA AS OUTPUT

1. GET THE DATA INTO THE COBOL PGM:		1. DEFINE THE VARIBALE  --> TEMP MEMORY ALLOCATION IN THE PGM , STORE UR DATA
														 --> LEVEL NUMBER + VARIBALE-NAME + DATA-TYPE
									2. INTIALIZE THE VARIBALE			--> VALUE -SPACE/ZERO..
									3. GET THE DATA INTO THE VARIBALE.

	--> 1. INTIIALIZING THE VARIBALE		--> VALUE
	--> 2. INPUT-OUTPUT STATEMENT		--> ACCEPT & DISPLAY
==>
INIITLAIZE THE COBOL VARIBALE:-	 

	2 REASON:		1.  WHEN UR PGM STARTS 1ST TIME -> ALLOCATE THE MEMORY SPACE -. WHICH WILL ALREADY HAVE PREVIOUS PGM DATA

						WE NEED TO REMOVE THOSE UNKNOW VALUE  - INITIALIZING THE VARIBALE.

				2. WHEN WE PROCESS DATA -> WE DO ON MULTIPLE RECORD  
					
						U GOT 1ST RECORD -> VARIBALE -> PROCESS -> SEND IT
						U SECOND RECORD  -> REMOVE THE PREVIOUS VALUE -> START OVER A NEW MEMORY

	INITILIZING CAN BE DONE IN 2 WAYS:		1. VALUE CLAUSE				--> DATA DIVISION -> DECLARING THE VARIBALE.  <<1ST VALUE
										2. MOVE/INITIALIZE KEYWORD		--> PROCEDURE DIVISION


VALUE CLAUSE :  IS USED TO INITIALIZE THE VAIABLE -WITH A DEFAULT VALUE.
				-> PGM STARTS - SYSTEM ALLOCATE MEMORY SPACE -> DEFAULT VALUE WILL BE ASSINED.

		>> NUMERIC DATA		->  01  VAR-A		PIC		9(03)  VALUE  ZERO.		<< FIGURTIVE CONSTANT	
								01  VAR-B		PIC		9(03)  VALUE  100.			>> NUM CONSTANT.
		
		>> ALP-NUM			-> 	01  VAR-A		PIC		X(03)	VALUE  SPACE.
							->	01  VAR-B		PIC		X(04)	VALUE 'ANIL'.		>> ALP-NUMERIC 

				-> IS COBOL LANG -> CASE SENTITIVE ?? !!!

						DISPLAY -- display -> CONVERTING INTO  'DISPLAY'   > OPTION CAPS ON << ALWAYS ACTIVE

						'Error in claim data'  < constant   ->  CAPS OFF

								'A' is not euqal 'a'  --> 

		>> SWTICH VARIBALE:	 DEVELOPER LOGIC VAIRBALE..
							
			ON/OFF  - TRUE/FALSE (T/F) ->  0/1  ->  YES/NO (Y/N)

				01  WS-SWITCH-VARIBALE			PIC		X(01)   VALUE SPACE.


		>> HARD CODED DATA VAIRBALE***:

				HOW THE PROJECT IS PREPARED?? -> 90% OF THE DATA IS CREATED BY BUSINESS USER/CUSTOMER 
											-> 10% DATA COME FROM PGM

					APPLICATION FOR CLAIM AS A CUSTOMER -> DETAILS?   1. POLICY NUMBER  2. NAME ADRESS 3. CLAIM AMT  << CUSTOMER DATA
																	1. CLAIM-STATUS??

				01  WS-CLAIM-STATUS		PIC	X(10)  VALUE  'APPROVED'.


==> INPUT-OUTPUT STATEMENT*:-


	WAYS TO GET THE DATA AS INPUT -> COBOL PGM VARIBALE:

			1. VALUE						-> WITHIN THE PGM -CONSTANT INPUT
			2. ACCEPT STATEMENT			-> JCL -> DD ->//SYSIN DD *
			3. READ STATEMENT				-> FILE 
			4. SELECT QUERY -SQL			-> DB2 TABLE
			5. RECEVIE COMMAND				-> CICS -SCREEN

	WAYS  TO SEND THE DATA AS OUTPUT -> 

			1. DISPLAY				->  SPOOL -> TEMP SPACE 
			2. WRITE STATEMENT			->  FILE
			3. INSERT/UPDATE -SQL		-> TABLE 
			4. SEND COMMAND			-> CICS SCREEN

==> TODAY:

ACCEPT  -> DISPLAY::-
---

ACCEPT STATEMENT:    USED TO GET AN INPUT DATA TO THE VAIRBALE.
				WHEN U CODE ANY ACCEPT STATEMENT - THE INPUT VALUE MUST BE PASSED THRU JCL

	SYNTAX:
				ACCEPT  VARIABLE-NAME-1.				EX:		ACCEPT CUST-NAME
				ACCEPT  VARIABLE-NAME-2.						ACCEPT ACCT-BAL

	IN RUN JCL**
				//SYSIN DD *								//SYSIN DD *
				INPUT-VAL-1								ANIL KUMAR
				INPUT-VAL-2								??			 9(03) --> 123 , 
				/*										/*					  12 -> INVLAID -> 012  <VALID
				//															  1  -> INVALID -> 001  >VALID
			
																	9(3)V9(02) -> 1. 123.45		--> INVALID  (S0C7)
																				2. 12345	-> VALID DATA

																	S9(03)	 ->  1. +123		==> INVALID
																				 2.  123		==? VAILD

===> ABOVE IS BOOK POINT <<== ==>BELOW IS PROJECT POINT <===

APPLICATION-A:	-> 100 PGM => OUT OF THESE 100 PGM -> 3-5 PGM USE ACCEPT

	-> PGM -> 2 KIND OF INPUT		1. PROJECT-PROD DATA INPUT		--> ALL SALES DATA FILE
								2. DEVELOPER INPUT			--> COUNTRY NAME , BRANCH CODE , Y/N , DATE    -BUILDING THE LOGIC

 EX: -> USER >  ANIL IS DEVELOPER -.>>  TO CREATE A  MONTHLY SALES REPORT FOR COUNTRY OF CANADA


		ANIL -> CODED A NEW COBOL:P1	1. INPUT ->  USED A FILE OF ALL SALES DETAILS OF ALL COUNTRY 
										2. LOGIC
												CONDITION -> IF COUNTRY-NAME = 'CANADA'
									3. OUTPUT -> CREATE THE REPORT.

				USER CHECK THE REPORT -> HAPPY -> MOVE PRODUCTION..

	-> ANOTHER USER -->  I NEED THE SIMILAR REPORT -> 'INDIA'

		
	DEV-1	-->  TOOK THE PGM P1  -> COPIED THE PGM -> P2 -> IN THE PGM -LOGIC 

							IF COUNTRY-NAME = 'INDIA'  -> OUTPUT

		--
	DEV-2	-->	 USED THE SAME  P1  > MADE A CHANGE IN THE LOGIC AS BELOW..

							ACCEPT WS-COUNTRY-NAME.
							IF COUNTRY-NAME  =  WS-COUNTRY-NAME
									-> OUTPUT

				//SYSIN  DD *
				INDIA
				/*
				//SYSIN  DD *
				CANADA
				/*
				//SYSIN  DD *
				US
				/*
	
==>
DISPLAY STATEMENT:-
				1. USED TO PASS A MESSAGE/CONSTANT  OR  DATA OF A VAIRBALE  -TO SPOOL
				2. THE MESS/VALUE => STORED IN  DD NAME  'SYSOUT'

	SYNTAX:		DISPLAY  ' MESSAGE  '    < CONSTANT
				DISPLAY  VARIABLE-NAME		-->   SYSTEM WILL PRINT VALUE THAT WAS STROED IN THE MEMORY
				DISPLAY  'MESSAGE '  VAIRBALE-NAME


			DISPLAY  'TOTAL IS '			> O/P  SYSOUT ->  TOTAL IS
			DISPLAY  CUST-NAME-VAR			>O/P   SYSOUT ->  ANIL KUMAR

			DISPLAY  'CUSTOMER NAME IS'   CUST-NAME.		O/P		-> CUSTOMER NAME IS  ANIL KUMAR

==ABOVE IS BOOK POINT <=    ==> BELOW IS PROJECT POINT <==

APPLICATION-A	-->  100 PGM   -OUT OF THESE 100 PGM -> 100 PGM USE IT.

		DISPLAY STATEMENT -> 1. IS NOT USED TO DISPLAY THE PROJECT DATA  (PUT THEM IN FILE/TABLE)



EX;		> ANIL IS SUPT ROLE

			ON A DAY ->  JOB J1 -> ABEND (ABNORMAL END-FAILED)

					SPOOL -> JOB J1 ->  STEP3-P1 ABENDED
																									HOW LONG
			ANALYSIS		1. TO CHECK 3000 LINE OF PGM -FIND WHERE IS ABEND HAPPENED						?? MANY HOURS - DAYS
						2. TO CHECK MILLION RECORD FILE -> FIND WHICH RECORD IS CAUSING THE ISSUE			?? NOT POSSIABLE

		IN THE SUPT -> SKILL + TIME  -> ABEND -> 2-4HR (SLA-RULES)

	-> DEVELOPER:		-> WHEN HE WANT TO ABEND THE PGM

			1.CLUES:
					DISPLAY  'ERROR IN  2000-PARA'
					DISPLAY  'ERROR REASON CODE '   ABEND-CODE
					DISPLAY  'LAST RECORD IN PROCESS IS'   ACCT-NUMBER

																									HOW LONG
			ANALYSIS		1. TO CHECK 3000 LINE OF PGM -FIND WHERE IS ABEND HAPPENED						?? 1MIN
						2. TO CHECK MILLION RECORD FILE -> FIND WHICH RECORD IS CAUSING THE ISSUE			?? 1 MIN


			2. AUDIT DISPLAY
							PROCEDURE DIVISION.
							000-MAIN-PARA.
									DISPLAY 'PGMNAME  STARTED'.

									DISPLAY  'TOTAL INPUT RECORD COUNT '  WS-IN-REC-CNT.
								    	DISPLAY  'TOTAL OUTPUT RECORD COUNT '  WS-OT-REC-CNT.
									STOP RUN.


===> CODE A PGM ->  VALID DATA			-->  PROCESS IT 
				  INVALID DATA		-->  1. SKIP THE DATA		--> ERROR FILE - CORRECT THEM LATER -> PROCESS NEXT DAY    
										2. ABEND THE PGM		--> DISPLAY THE CLUES --> SUPT - FIX ISSUE NOW -- RERUN NOW ITSELF

















COBOL CLASS 02:- VARIABLE

AS DEVELOPER:	3 STEPS		1. CODE THE COBOL PGM		2. COMPILE -LOAD	3. CODE THE RUN JCL -EXECUTE

	>> CODE THE COBOL PGM:		1. GET THE DATA AS INPUT 
								2. APPLY BUINESS RULES + CONDITION + CAL + FILTER..
							3. SEND THE DATA AS OUTPUT

	>> GET THE DATA AS INPUT INTO THE PGM**

			1. DEFINE THE VARIABLE (MEMORY IN THE PGM)
			2. INITIALIZE (SET A DEFAULT)  VALUE
			3. GET THE DATA FROM OUTSIDE OF THE PGM


-> HOW TO DEFINE A VARIABLE**:

VARIABLE ->   ITS A TEMP MEMORY SPACE ALLOCATED IN THE PGM , USED TO STORE AND PROCESS THE DATA

		FROM INPUT -IF WE ARE GETTING 2 VALUE	-  WE NEED 2 VAIRBALE PGM
								10 VALUE		-  WE NEED 10 VARIABLE PGM

	IN COBOL --  VARIABLE	-> 2 TYPES		1. GROUP VARIABLE			-- IT CAN BE SUB-DIVIDED INTO 1 OR MORE ELEMENTARY ITEM
										2. ELEMENTARY VARIBALE		-- SINGLE ELEMENT TO STORE THE VALUE (CANNOT BE SUB-DIVIDED)

			EX:	 ACCOUNT-DETAILS	-> GROUP  - ACCT-NUM , CUST-NAME , ACCT-TYPE
				 ACCOUNT-BALANCE	-> ELEMENTARY

			EX:	 CUSTOMER-ADDRESS	-> 	GROUP
				  CITY			-> ELEMENTARY

			EX:		VARA
					VARB

		HOW TO TELL THE SYSTEM:		IN ANY PROG LANG -> WE FOLLOW  'SYNTAX"  => RULE TO CODE A LINE IN PGM

VARIABLE SYNTAX:	2 TYPE

			GROUP VARIBALE:		LEVEL-NUMBER		VARIABLE-NAME.		(END WITH A DOT)

			ELEMENTARY VARIABLE:	LEVEL-NUMBER		VARIABLE-NAME		PIC		(FOLLOW BY PIC)


		EX:		01 GRP-VARA  PIC			-ELEMENTARY VARIABLE
				01 ELE-VARB.				-GROUP VARIBALE


--> LEVEL-NUMBER:		IN COBOL , ALL VARIBALE MUST BE PREFIXED BY A NUMBER 


		WE HAVE ->  01,02,03,04....49  ,  66 ,77, 88

	01 --> USED TO DEFINE A GROUP AND ELEMENTARY AS WELL
		02-49  -> THESE VARIABLE SHOULD BE UNDER 01
				-> THESE NUMBER CAN BE USED TO DEINFE ELEMENTARY & ALSO SUB-GROUP.
				 -> WHEN ADDING ELEMENTARY VARIBALE UNDER A SUB-GRP - INCREASE THE LEVEL NUMBER

			==> USE THE LEVEL NUMBER - > ODD SERIES , MULTIPLE 5/10		> EX:  01 - 03,05,07..    EX:  01 -05,10,15..	

	77 --> ONLY FOR ELEMENTARY  -  FORGET , USE 01 ALWAYS	

	66 - RENAMES  , 88 - COND NAME CONDITION  --> LATER				

DATA RECORD:

A1111,ANIL KUMAR,HYD,TS,98765678,SAVING,2022-11-11,2023-11-11,98789.00


	EX:		01 ACCOUNT-DETAILS.
				03 ACCT-NUMBER		PIC			X			
				03 CUST-NAME			PIC			X
				03 CUST-ADDRESS.
					05 CITY			PIC			X
					05 STATE			PIC			X
					05 PINCODE		PIC			X
				03 ACCT-TYPE			PIC			X
				03 ACCT-OPEN-DATE		PIC			X/9
				03 ACCT-CLOSE-DATE.
					05 YEAR.	
						07 CENTURY	PIC			X/9
						07 YY		PIC			X/9
					05 MONTH			PIC			X/9
					05 DAY			PIC			X/9
				03 ACCT-BALANCE		PIC			S-9-V
			
			01 TOTAL-ACCOUNT-BALANCE	PIC
					OR
			77 TOTAL-ACCOUNT-BAL		PIC
					
>> VARIABLE NAME::
			BOOK:		1. 32 CHAR MAX
						2. SHOULD NOT START WITH A NUMBER
						3. SHOULD NOT USED COBOL KEYWORD			01 DIVISION   - ERROR
						4. WE CANNOT USE 2 WORD AS VRAIBALE NAME -> IF U WANT TO USE -> CONNECT THE WORD USING HYPEN (-)

	==> ABOVE IS BOOK POINT <===  ==> BELOW IS THE PROJECT POINT <===

						5. ALL THE VARIABLE SHOULD BE SELF EXPLAINED.					
						6. VARIBALE SHOULD POINT TO THE DATA SOURCE**


ANIL IS NEW TO THE PROJECT -

	Q? 	IN PGM P1 ->   01  CS  PIC ...			COBOL SKILL -ITS AN ELEMENTARY 
												PROJECT -> WHAT THIS   CS MEANS?? -> 

	Q?  IN  PGM P2 ->  01 CLAIM-STATUS	PIC...		-> ELEMENTARY VARIABLE(PIC) +  BUSINESS -> STATUS OF CLAIM ,APPROVE/REJECTED


	IN THE PGM P3 ONLY - ANIL -NEW - HE SEES AS BELOW

			CLAIM-STATUS						-> WITH NO PREFIX/NO SUFIX  ->  DATA SORUCE VARIABLE FILE/TABLE
			WS-CLAIM-STATUS					->  WS-   > WORKING-STORAGE  ->  ALL DEVELOPER VARIABLE (WE DEFINED FOR OUR LOGIC)
			DCL-CLAIM-STATUS					->  DCL- / HS-  -->   TABLE VARIABLE
			CLAIM-STATUSI						-> I - SUFIX  -> CICS INPUT VARIBALE
			CLAIM-STATUSO						-> O - SUFIX  -> CICS OUTPUT VARIABLE
			CLAIM-STATUS-HOLD					-> HOLD -> TEMP DEVELOPER VARIABLE (LOGIC)


==> PIC CLAUSE**: -	USED FOR ONLY ELEMENTARY
				-	USED TO PROVIDE - DATA TYPE * SIZE FOR THE MEMORY ALLOCATION.

	
	IN THE PGM -> DEFINE THE VAIRBALE MEMORY SPACE -> THEN WE STORE THE DATA

		DATA	->   TYPES		1. NUMERIC 			-9
							2. ALPBATIC			-A			- DO NOT USE
							3. ALPHANIUMERIC		-X

1. NUMERIC	-->	9	(0-9)		EX:		123			PIC	999 / 9(03).			9 - NUMERIC  03 - 3 BYTES MEMORY SPACE
										+123/-123		PIC	S9(03).				S - SIGN , 9 - NUM  ,  03 - BYTES
										+/- 123.45	PIC  S9(03)V9(02).			S - SIGN , 9 -NUM , V - ASSUMED DECIMAL , 03+02 - BYTES
				MAX - S9(18). 
					 S9(16)V9(02)


2. ALPH		->  A				EX:		ANIL 		PIC	A(04).		FORGET THIS


3. ALP-NUMER	-> 	X				EX:		'ANIL'		PIC	X(04)
										'1234'		PIC	X(04)
									'ANIL1234'		PIC	X(08).


	WHEN WE ARE DEVELOPER -> WILL THE CUST/USER -> WILL THEY COME AND TELL THE TYPE IN THE PGM..

		WHICH ONE I SHOULD USE?  

			VALUE ->   12345		-->  1. NUM-9    2. ALPNUM-X		?? ANSWER? -> 1/2

		1. IF THE VALUE IS REQUIRED TO BE USED FOR CALCUATION --> MUST DEFINE IT AS NUMERIC ,, IF NOT - ALP-NUM.

				EX:  PINCODE -   PIC  ->  AL-NUMERIC 
	

>> ACCOUNT NUMBER:		 PIC   X.

			ACCOUNT-NUMBER		PIC		X(04).	-POSSIABLE VALUE:	0001-9999 , A000-A999,Z999,ZZ99,ZZZ9,ZZZZ

				EX:	1ST CUSTOMER	-> ACCT-NUM		-> 0001
					2ND CUSTOMER  -> ACCT-NUM	-> PREVIOUS-ACCT-NUM + 1 ==> ERROR

			ACCOUNT-NUMER		PIC		9(04).		-POSSIABLE VALUE:	0001-9999

				EX:  1ST CUSTOMER  -> ACCT0NUMBER	-> 0001
					2ND CUSTOMER	->  ACCT-NUMBER	-> 0001 + 1 = 0002 => VALID
							..AFTER 1 YEAR..
					9999 CUSTOMER	->  ACCT-NUMBER	-> 9998 + 1 => 9999 > VALID
					NEW CUST - BILLION $ -DEPOSIT -->  9999 + 1 ==> ??			->  1. SAY NO TO CUSTOMER -> U DONT HAVE ACCT NUMBER
																			2. REMOVE OLD CUST -> ADD THIS NEW CUST 

		PGM VS DATA 	-> FIRST UNDERSTAND THE DATA

ACCOUNT-NUMBER ,  CLAIM-NUMBER , POLICY-NUMBER , AAHAR CARD , PASSPORT , SSN , ORDER , A LOT THEM HERE...

	
			KEY FIELDS		1. ALWAYS INCREASE (NO LIMIT)
							2. NO DUPLICATE

		DATA-TYPE -. COMBINATION		

		03 ACCT-NUMBER.
			05	BRACNH-CODE/IFCI	PIC	X(04).	->  0001							0002		->9999,A999,Z999,ZZ99,Z999,ZZZZ
			05   AREA-CODE		PIC	X(02).	->   01		02			99		01
			05 ACCT-NUM			PIC	9(06).	-> 01-99999	01-999999				01-99999


















































































COBOL CLASS 01:-  Introduction to COBOL  
-----------------
MAINFRAME -->  IT IS A BIG COMPUTER  -> USED FOR DATA   1. STORE  &  2. PROCESSING

	PROCESSING	->  1. BATCH PROCESS		2.  ONLINE PROCESSING

						1. BUSINESS LOGIC ->		COBOL.

COBOL -> WE CANNOT DEVELOPER ANY SOFTWARE
		-> WE CAN CODE BUSINESS LOGIC -> TO MAINTAIN THE APPLICATION

COBOL ->   VERY EASY
		-> MOSTLY ENGLISH

	--> PGM ARE LENGTHY  -> SMALL LOGIC PGM --> 300 LINES OF CODE

==> IF AM INTO MAINFRAME -APPLICATION
	
	2 THINGS	->		1. AS A DEVELOPER -> WE NEED TO KNOW HOW TO CODE THE PGM   -> FALL INTO A DEVELOPER PROJECT
					2. AS A ANALSYST/SUPT ROLE	-->  1. ALONG WITH THE CODING THE PGM  2. HOW TO ANALYSIS OF THE PGM
==>
HOW TO CODE A COBOL PGM** :-

	PGM FORMAT:	DIVISION.
				  SECTION.
					PARAGRAPHS
						STATEMENT.		--> COMMAND/INSTRUTION TO SYSTEM -HOW TO PROCESS THE DATA.


DIVISION ->   4 DIVISION

				1. IDENTIFICATION DIVISION. (ID DIVISION)
				2. ENVIRONMENT DIVISION									--OPTIONAL
				3. DATA DIVISION.										--OPTIONAL
				4. PROCEDURE DIVISION.

>> ID DIVISION:		USED TO PROVIDE THE IN-PROG DOCUMENTATION DETAILS.
					-> WE HAVE ONLY PARAGRAPHS..
					-> OUT OF THESE 6 PARA -> ONLY  PROGRAM-ID IS REQUIRED.
					-> PROJECT PROG ->  PROGRAM-ID - AUTHOR & DATE-WRITTEN.

			ID DIVISION.
			PROGRAM-ID. 		NAME-OF-PGM.
			AUTHOR.			UR NAME.
			DATE-WRITTEN.  	TODAY-DATE.
			DATE-COMPILED. 	TODAY-DATE.
			INSTALLTION.		APPLICATION-NAME.
			SECURITY.			WARNING MESSAGE.

PGM NAME ->  8 CHAR (ALP-NUM)	-->   EX:  ANILPGM1   ANILPGM2  , TESTPGM1 , TESTPGM2	--> VALID NAME??   NOT VALID..

		PROJECT =>  APPLICATION -A		--> Z1YE*  -> Z1YE0001 - Z1YE9999		-> NEW PROJECT PROGRAM -> Z1YE**
				  APPLICATION -B		--> Z1YN*  -> Z1YN0001 - Z1YN9999



>> ENVIRONMENT DIVISION:-	 USED TO DEFINE THE REQUIRED FILE IN THE PGM** OF BATCH APPLICATION (FOR ONLINE - NO NEED)

	DATA-STORE-.FILE/TABLE	-> PROCESS-GET THE DATA (COBOL - LOGIC +CAL -SEND) -> FILE/TABLE.

	ENVIRONMENT DIVISION.
	INPUT-OUTPUT SECTION.
	FILE-CONTROL.
		DEFINE THE ALL FILE (INPUT - OUTPUT)


==		COBOL PGM TYPES	==						== IS ENV DIVISION REQUIRED.? (YES/NO)
			===
		1.	ONLY COBOL											NO
		2.	COBOL + FILE									YES
		3.	COBOL + DB2											NO
		4. 	COBOL + DB2 + FILE								YES
			--------------------------------------------------------------------------------------ONLINE PGM - NO ENV REQUIRED.
		5.  COBOL + CICS											NO
		6.  COBOL + CICS +FILE										NO			-- NOT REQUIRED  --> FCT - FILE CONTROL TABLE
		7.  COBOL + CICS + DB2										NO
		8.  COBOL + CICS + FILE + DB2								NO			-- NOT REQUIRED



>> DATA DIVISION:-   =>  USED TO DEFINE ALL VARIABLE REQUIRED IN THE PGM
----
	
	VARIABLE:-    TEMP MEMORY SPACE ALLOCATED IN THE PGM - TO STORE AND PROCESS THE DATA
					-> SCOPE/LIFE OF A VAIBRALE -> TILL THE END OF PGM.
							=> UR PGM COMPLETED -> VARIABLE MEMORY  -> DELETED.
		-> WHY I NEED A VAIABLE??

	DATA (FILE/DB2)  -> GET DATA INTO PGM  (COBOL - MEMORY?? HOLD THAT -> DEFINE MEMORY -VARIABLE + PROCESS ) -> SEND -> FILE/TABLE
	--
	A1111,ANIL,5000  < DEPOSIT -2000			 ACCT-NUM,CUST-NAME,ACCT-BAL, DEP-AMT << VARIABLE
															ACCT-BAL + DEP-AMT  << PROCESS		==>  A1111,ANIL,7000
													
									==== SHOPPING IN SUPER MARKET  ====
		
	SUPER MARKET																						HOME
	ITEM -HERE STORED			===>  BAG'S / COVER / -CARD BOX ===========>									ITEM (FREE/CONT/USE)


			DATA DIVISION.
			FILE SECTION.						-> FILE VARIBALE.
			WORKING-STORAGE SECTION.			-> DEVELOPER VARIBALE -> USE FOR BUILDING LOGIC  + DB2 
			LINKAGE SECTION.					-> DIFF STYLE -> LINKING VARIABLE


>> PROCEDURE DIVISION:
				>>	USED  TO CODE ALL BUSINESS LOGIC
				>>   WE DONT HAVE PRE- DEFINED SECTION / PARAGRAPHS.			
				>>   WE AS DEVELOPER WE CAN CODE OUR OWN SECTION/PARAGRAPHS	
	>> 80% OF UR WORK WILL BE HERE.

	>> WE CODE THE STATEMENT -> COMMAND TO SYSTEM TELLING - HOW TO PROCESS THE DATA

		=> STOP RUN  -> COBOL STATEMENT ->COME OUT OF THE PGM ( END OF THE COBOL PGM)

		8TH COL
		ID DIVISION.
		PROGRAM-ID.  CBLPGM01.
		AUTHOR.	 NAME.
		DATE-WRITTEN.  TODAYS.

		ENVIRONMENT DIVISION.
		INPUT-OUTPUT SECTION.
		FILE-CONTROL.
		
		DATA DIVISION.
		FILE SECTION.
		WORKING-STORAGE SECTION.
		LINKAGE SECTION.

		PROCEDURE DIVISION.
		000-MAIN-PARA.						COMMON.
			12 COL
			DISPLAY	' HELLO  ALL'.
			DISPLAY 	' WELCOME TO MAINFRAME TRAINING'.
			
			STOP RUN.

COBOL -> 	COBOL CODE SHEET**		-> PGM LINE -> 1-80 COL LENGTH

		1-6 -> LINE NUMBER -> SYSTEM AUTO..

			7TH COL -> USED FOR CODE A COMMENT   (COMMENT -> SYSTEM WILL IGNORE THOSE LINES)

		8-11  ->  AREA-A	 >  HEADER > DIVISION , SECTION , PARAG , 01 LEVEL		-> BUT WE ALWAYS -START 8TH ONLY
		
		12-72  -> AREA-B	-> STATEMENT   (DISPLAY -STOP RUN)	

		73-80	--> CHANGE TAG -> I WILL SHOW U IN PROJECT.

	-->  7-72 ->   COMMENT + HEADER + STATEMENT
				 	7	   8		    12 

--> ASKED ME TO CODE A COBOL PGM:		1. WHAT ARE MY IN/OUTPUT ARE   1. FILE  -> OKAY -STYLE-1
																2. TABLE -> OKAY -STYLE-2
									2. ID - FINISH IT
									3. ENVIRONMENT ->  CHECK POINT-1
									4. DATA DIVISION (COMPLET IT PARTITALY)  - UNTIL THE LOGIC IS COMPLETED..
									5. PROCEDURE DIVISION (COMPLETE IT )
									6. COMPILE + TEST + RETEST..

			PGM vs DATA		-> CHOOSE 1 ->  DATA**

--> ANALYS THE PGM:	-> FULL PGM - CHECK AND TELL ME -WHAT THE PGM DOING??

			BIG PGM:			1. 	CHECK THE COMMENT OF THE PGM**	
							2.	ENVIRONMENT DIVISION			--. INPUT??  IS IT FILE A PGM YES -> STYLE 1 , DB2 PGM -STYLE-2
							3.  PROCEDURE DIVISION.
							4. IF REQUIRED -> CHECK THE DATA DIVISION.  (THIS IS ONLY IF REQUIRED)				

===========================================================================================================---
MAINFRAME ->  1.  COBOL    2.  JCL   3.  FILE& DB2   4. CICS	5. Z/OS *TSO/ISPF

COURSE PLAN:

1. COBOL + JCL(LITTLE)		-> 2/3 WEEKS
2. JCL (PRODUCTION)		-> 8-9 SESSION
3. DB2					-> 10 SESSION
4. CICS					-> 10 SESSION

-- DAILY -> 1 HR  9.30PM (DAY SAVING -NOV-6)	-- MON-SUN - IN CASE IF WE MISS ANY WEEKDAYS -> SUNDAY..

-> NOTES , RECORDING , PROGRAM , ASSIGMENT  -> SHARE IN THE SKYPE CHAT
									--> DOWNLOAD THEM < 30 DAYS  (CHECK THEM -IF THEY PLANING)
										-> DO NOT SHARE TO ANYONE...

--> PRACTICALS		-> 1. HERCULES -SOFTWARE
					-> 2. SEND THE SOFTWARE  -> GOOGLE DIRVE (DONT CHECK IN MAIL)
					-> 3. JUST DOWNLOAD THEM ALL - DO NOT OPEN 
					-> 4. CONNECT - SETUP - TEST IT -- GOOD 
					-> 5. USE IT AS PERSONAL SOFTWARE -> ANYTIME , ANYWHERE, ANY HOURS  
		-> SYSTEM -
				 WINDOWS - 8 GB RAM  (4GB - SOFTWARE WILL SLOW)

==BONUS :
			1. TRAINING ->  I WILL SHOW REAL TIME -CASES/SYSTEM/PROGRAM/ABENDS		-
			2. INTERVIEW -> I WILL TRAINING ON THE TOOLS - HELP FOR INTERVIEW.
																		-> CANNOT RECORD THEM <- SHARE GOOD DOCUEMENT 
				==> DO NOT MISS UR CLASS -- COMPLETE UR TASK <===
====
FEE ->  7200/-	==> 200/-  => 7000 > TODAY , TOMORR , NEXT  3 DEMO..


